<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description"
    content="Assignment portal for Eric Burns in WDD 330: Web Frontend Development, Week 07 Notes">
  <title>Notes | Week 07</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="../../css/normalize.css">
  <link rel="stylesheet" href="../../css/small.css">
  <link rel="stylesheet" href="../../css/medium.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <div id="content">
    <header class="header">
      <h1>Notes | Week 07</h1>
    </header>
    <nav class="nav">
      <ul>
        <li class="home"><a href="../../index.html"><span class="fa fa-home"></span> Home</a></li>
        <li class="home"><a href="../week07/index.html"><span class="fa fa-arrow-right"></span> Week 07</a></li>
      </ul>
    </nav>
    <main class="main">
      <h2>Notes - JavaScript Novice to Ninja</h2>
      <h3>Chapter 11 - Further Functions</h3>
      <p>The following notes are of particular areas that I was less familiar with, didn't fully realize, or would
        like to have as a quick reminder.</p>
      <ul>
        <li>Call() method: allows you to invoke a function and pass an object that would bind <code>this</code> to.
          First argument is always the argument that takes the value of <code>this</code>.</li>
        <li>Apply() method: works the same as Call(), except that arguments are provided as an array.</li>
        <li>Can add custom properties to functions, as in <code>square.description = 'does something';</code></li>
        <li>Memoization, allows us to utilize the benefit of the cache property. <code>square.cache = square.cache ||
            {};</code></li>
        <li>Immediately invoked function expressions (IIFE). <code>(function(){ //do something })();</code>. This is a
          technique of namespacing, so all variables are wrapped within the scope of the function.</li>
        <li>Use IIFEs to keep temp variables truly temporary, so they are out of scope globally.</li>
        <li>With ES6, IIFEs may not be as useful, as you can use block scope using const and let to keep those variables
          out of the global namespace.</li>
        <li>Can also contain 'use strict' inside IIFEs</li>
        <li>Modules may be a better approach to segmenting code than using IIFEs.</li>
        <li>It is possible to redefine a function within itself to do something different after it is called the first
          time. This is called <em>Lazy Definition Pattern</em> and is used when some initialization code id required
          the first time it is invoked.</li>
        <li>Init-Time Branching: we can use feature detection to define the function based on whether the browser
          supports the function. You then return an invocation of the function as in <code>return ride();</code> which
          is not done again, as the function is redefined.</li>
        <li>Recursion: when a function invokes itself until a certain condition is met.</li>
        <li>Event-driven asynchronous programming: callbacks invoked when an event happens, such as a click, keypress,
          file download, data returned, or the result of a complex calculation.</li>
        <li>setTimeout() function is asynchronous.</li>
        <li>JavaScript is single threaded, so only one task can happen at once.</li>
        <li>Callbacks can be overused.</li>
        <li>Error-first callback style popularized by Node.js. Callbacks have two arguments, error, and data returned
          that can be used in the body of the callback.</li>
        <li>Promise: the future result of an asynchronous operation. Promises don't do anything that can't already be
          achieved using callbacks, but they help simplify the process.</li>
        <li>Promise life-cycle: when promise is created, calls asyn operation and is then said to be pending. Remains in
          this state while operation is taking place. Promise is said to be unsettled. Once operation has completed,
          promise is settled. Settled promise is either <em>resolved</em> or <em>rejected.</em></li>
        <li>Creating a promise: <code>const promise = new Promise( (resolve, reject) => { if (success) { resolve(value);
            } else { reject(error); } });</code></li>
        <li>promise.then method: once settled, can deal with the outcome --> two arguments: resolve function and
          rejection function.</li>
        <li>promise.catch method: alternative to .then method, to specify what to do if the operation fails instead.
        </li>
        <li>promise.then.catch: can be chained.</li>
        <li>Chaining promises: much cleaner than using multiple callbacks. Example: <code>login(userName).then(user =>
            getPlayerInfo(user.id)).then(info => loadGame(info)).catch(throw error)</code></li>
        <li>Async Functions: allow you to write asynchronous code as if it was synchronous, using the await operator.
          Wraps the return value of the function in a promise that can then be assigned to a variable. Next line of code
          not executed until the promise is resolved.</li>
        <li>Abstraction: wrapping logic cleanly away inside a function.</li>
        <li>Generalized functions: using a callback to apply in a function. Example: <code>function random(a, b,
            callback) {... if(callback) { result = callback(result); } return result; }</code></li>
        <li>Functions that return functions: assign the function to a variable, then you can call that "new" function as
          in <code>const hello = returnHello(); hello()</code></li>
        <li>Closures: a reference to a variable that was created inside the scope of another function, but is then kept
          alive and used in another part of the program. Whenever a function is defined inside another function, the
          inner function will have access to any variables that are declared in the out function's scope.</li>
        <li>Returning functions: A closure is formed when the inner function is returned by the outer function,
          maintaining access to any variables declared inside the enclosing function. You then assign a variable to the
          return value of the outer function, as in <code>const closure = outer();</code>. The variable closure now
          points to the inner() function that is returned by the outer() function.</li>
        <li>Generators: used to produce iterators that maintain the state of a value. Defined using an asterisk symbol
          (*) as in <code>function* exampleGenerator() {}</code>. Returns a generator object that can be used to create
          an iterator that implements a next() method that returns a value every time the nxt() method is called.</li>
        <li>Functional programming: the ability to pass functions as arguments, return them from other functions, use
          anonymous functions and closures, are all fundamental elements of functional programming.</li>
        <li>Functional programming vs OOP vs Procedural programming: JavaScript can be used with all three paradigms.
        </li>
        <li>Pure functions: adheres to following rules:</li>
        <ul>
          <li>Return value should only depend on the values provided as arguments - not on values from somewhere else in
            the program.</li>
          <li>No side effects - does not change any values or data elsewhere in the program. Only makes non-destructive
            data transformations and returns new values, rather than altering any of the underlying data.</li>
          <li>Referential transparency. Given same arguments, will always return the same result.</li>
          <li>Therefore must have at least one argument and a return value.</li>
          <li>Functional programming uses pure functions as the building blocks of a program. The functions perform a
            series of operations without changing the state of any data. Each function forms an abstraction that should
            perform a single task, while encapsulating the details of its implementation inside the body of the
            function. This means that a program becomes a sequence of expressions based on the return values of pure
            functions. The emphasis is placed on using function composition to combine pure functions together to
            complete more complex tasks.</li>
          <li>Pure functions are more flexible, as they can be used as the building blocks for many different
            situations.</li>
        </ul>
        <li>Higher order functions: accept another function as an argument or return another function as a result, or
          both.</li>
        <li>Currying: allows you to turn a single function into a series of functions instead.</li>
      </ul>

      <p class="question">To what degree are recursive functions used for elegance and conciseness vs readability? I
        personally have to spend a lot of time studying a recursive function to understand what is happening. Is it
        fairly common to see in practice?</p>
      <p class="question">What are some practical examples of Closures?</p>

      <h3>Chapter 13 - Ajax</h3>
      <ul>
        <li>Ajax allows JavaScript to request resources from a server on behalf of the client, usually via JSON data.
        </li>
        <li>Same-Origin Policy: blocks requests from a domain that is different from the page making the request.
          Cross-origin resource sharing (CORS) allows resources to be requested from another website outside the
          original domain. Uses HTTP headers to indicate which domains can receive data.</li>
        <li>AJAX: asynchronous JavaScript and XML. XML was the first format for data to be sent, but JSON is easier to
          parse and more widely used.</li>
        <li>Fetch API: superseded XMLHttpRequest. Uses promises, and is much more streamlined than XMLHttpRequest.</li>
        <li>Fetch example: <code>fetch('URL').then(//code that handles the response).catch(//code that runs if server
            returns an error)</code></li>
        <li>OK method: returns true if status property is between 200 and 299, whereas a promise is only rejected in the
          case of a network error (meaning it would still allow a '404' error).</li>
        <li>Example: <code>fetch(url).then((response) => { if(response.ok) { return response; } throw
            Error(response.statusText);}).then( response => // do something with response ).catch( error =>
            console.log('There was an error'))</code></li>
        <li>Other properties of Response object: headers, url, redirected, type.</li>
        <li>Redirect method: redirect to another URL - currently no browser support.</li>
        <li>Text method: takes a stream of text from the response and returns a promise that resolves to a USVString
          object that can be treated as a string in JavaScript.</li>
        <li>Blob method: read file of raw data, i.e. images, spreadsheet, etc.</li>
        <li>JSON method: transforms JSON data into a promise that resolves to a JavaScript object. Example:
          <code>fetch(url).then( response => response.json()).then( data => console.log(Object.entries(data))).catch(
            error => console.log(error))</code></li>
        <li>Making a response object: <code>const response = new Response('Hello!' [this is the data to be returned,
            could be a file, JSON data, or a text stream], {ok:true, status:200, statusText: 'OK', type: 'cors', url:
            '/api'} );</code></li>
        <li>Request() constructor properties: url, method (GET, POST, etc., default is GET), headers, mode, cache,
          credentials, redirect. Used for more fine-grained control over the request.</li>
        <li>HTTP methods: GET, POST, PUT, PATCH, DELETE</li>
        <li>HTTP Headers: Example - <code>const headers = new Headers();</code> - used to pass on any additional
          information about a request or response. Typical for file type, cookie information, authentication
          information, and when last modified.</li>
        <li>Ajax Load and preloaders.net good resources for creating a spinner graphic for your site.</li>
        <li>JSONPlaceholder site: dummy site for testing sending and receiving JSON data. </li>
        <li>Noticed this in an example: getting the value of an element within a form by setting the name property of
          the input element in the form then accessing it as form.task.value - form would come from <code>const form =
            document.forms['id of form']</code></li>
        <li>FormData interface: Example - <code>const data = new FormData();</code> and then <code>const task = new
            FormData(form);</code></li>
        <li>Can add data to the FromData() object using append as in <code>data = FormData();</code> and then
          <code>data.append('height', 75);</code></li>
        <li>FormData interface shines when a form contains files to upload. Takes care of the heavy lifting.</li>
        <li></li>
      </ul>

      <p class="question">The text mentions the use of jQuery to handle ajax requests as an alternative to using the
        Fetch API, in an effort to protect against changes to its methods as a "living standard." What is the current
        popularity of jQuery in the industry now? Is it still used or only seen in legacy applications?</p>
    </main>
    <footer class="footer">
      <p>&copy; <span id="currentyear"></span> | Eric Burns | Washington, USA <span id="footer-pipe">| </span><br><a
          href="https://www.byui.edu/online" target="_blank">BYU-i Online Learning</a></p>
      <p class="datetime">Last Updated: <span id="datetime"></span></p>
    </footer>
  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js">
  </script>
  <script src="../../js/webfontload.js"></script>
  <script src="../../js/script.js"></script>
</body>

</html>